from core.InputHandler import InputHandler
from core.ScreenshotTool import ScreenshotTool
from core.models.Worms import WormRarity
from core.WindowHandler import WindowHandler
from core.Observer import Subscriber, Publisher
from core.constants.AutoGeneratedCoordinates import COORDINATES
from core.constants.GuiData import COMMON_WORM_COLOR, RARE_WORM_COLOR, EPIC_WORM_COLOR, LEGENDARY_WORM_COLOR, NO_WORM_COLOR
from core.Errors import PixelColorMismatchError, TimeoutStateError

from PIL import Image
import time

class GameInterface(Subscriber, Publisher):
    
    def __init__(self, input_handler: InputHandler, screenshot_tool: ScreenshotTool, window_handler: WindowHandler):
        super().__init__()
        self._input_handler = input_handler
        self._screenshot_tool = screenshot_tool
        self._window_handler = window_handler
        self._input_handler.subscribe(self)
        self._screenshot_tool.subscribe(self)
    
    def update(self):
        self.notify()
        
    # ==========================================
    # GAME STATE DETECTION METHODS
    # ==========================================
    
    # Home 
    def is_home_state(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_home_state"])
    
    def is_not_home_state(self):
        return not self.is_home_state()
    
    def is_accept_team_window_open(self):
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_accept_team_window_open"])

    def is_accept_team_window_closed(self):
        return not self.is_accept_team_window_open()

    def is_last_dungeon_window_open(self):
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_last_dungeon_window_open"])
    
    def is_last_dungeon_window_closed(self):
        return not self.is_last_dungeon_window_open()
    
    def is_difficulty_window_open(self):
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_difficulty_window_open"])
    
    def is_difficulty_window_closed(self):
        return not self.is_difficulty_window_open()
    
    def is_quest_window_open(self):
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_quest_window_open"])
    
    def is_quest_window_closed(self):
        return not self.is_quest_window_open()
    
    def is_zone_scrolldown_up(self):
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_zone_scrollbar_first_position"], False)

    def is_zone_window_open(self):
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_zone_window_open"])
    
    def is_refill_energy_window_open(self):
        return self._screenshot_tool.matches_expected_color(COORDINATES["no_button_not_enough_energy"])
    
    # Fishing
    def is_fishing_state(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_fishing_state"])
    
    def is_not_fish_state(self):
        return not self.is_fishing_state()
    
    def is_trash(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_trash"])
    
    def is_fish_min_range(self) -> bool:
        return not self._screenshot_tool.matches_expected_color(COORDINATES["fish_minimum_range"])

    def is_fish_max_catch_rate(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["fish_max_catch_rate"], False)
    
    # Dungeon
    def is_dungeon_auto_pilot_disabled(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_auto_pilot_disabled"])
    
    def persuasion_has_succeeded(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["persuasion_has_succeeded"])

    def is_in_persuasion_state(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_persuasion_state"], False)
    
    def is_not_in_persuasion_state(self) -> bool:
        return not self.is_in_persuasion_state()

    def is_dungeon_completed(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_dungeon_finished"], False)
    
    # Other
    def is_disconnected(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_disconnected"])

    def is_game_not_running(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_game_not_running"])

    def is_game_running(self) -> bool:
        return not self._screenshot_tool.matches_expected_color(COORDINATES["is_game_not_running"], False)
    
    def is_game_ready(self) -> bool:
        return self._screenshot_tool.matches_expected_color(COORDINATES["is_news_window_open"], False)

    # ==========================================
    # GAME INTERACTION METHODS
    # ==========================================
    
    # Menu
    def click_quest(self):
        self._input_handler.click_menu(COORDINATES["quest"], "quest", self.is_not_home_state)
    
    def click_dungeon(self, zone: int, dungeon: int):
        self._input_handler.click_menu(COORDINATES["dungeon"][str(zone)][str(dungeon)], "dungeon", self.is_quest_window_closed)

    def click_run_last_dungeon(self):
        self._input_handler.click_menu(COORDINATES["run_last_dungeon"], "last dungeon", self.is_last_dungeon_window_closed)

    def click_difficulty(self, difficulty: str):
        self._input_handler.click_menu(COORDINATES[str(difficulty).lower()], "difficulty", self.is_difficulty_window_closed)

    def click_accept_team(self):
        self._input_handler.click_menu(COORDINATES["accept_team"], "accept team", self.is_accept_team_window_closed)

    def click_fish_menu(self):
        self._input_handler.click_menu(COORDINATES["fishing"], "fishing", self.is_not_home_state)

    def click_zone_button(self):
        self._input_handler.click_menu(COORDINATES["zone_button"], "zone", self.is_quest_window_closed)

    def close_menu_windows(self):
        self._input_handler.close_windows(self.is_home_state)
    
    def click_zone_up_arrow(self):
        self._input_handler.click(COORDINATES["zone_up_arrow"], delay=0)
    
    def click_zone_box(self, box: int):
        self._input_handler.click(COORDINATES[f"zone_box_{box}"])
    
    def click_zone_down_arrow(self, count: int):
        for _ in range(count):
            self._input_handler.click(COORDINATES["zone_down_arrow"], delay=0)

    # Fishing
    def click_worm_window(self):
        self._input_handler.click_menu(COORDINATES["select_worm"], "select worm", self.is_not_fish_state)

    def close_fish_window(self):
        self._input_handler.close_windows(self.is_fishing_state)

    def click_fish_play(self):
        self._input_handler.click(COORDINATES["fish_play"])
    
    def click_fish_start(self):
        self._input_handler.click(COORDINATES["fish_start"], delay=0)
    
    def click_fish_cast(self):
        self._input_handler.fast_click(COORDINATES["fish_cast"])
    
    def click_fish_catch(self):
        self._input_handler.fast_click(COORDINATES["fish_catch"])

    # Dungeon
    def click_auto_pilot(self):
        self._input_handler.click(COORDINATES["auto_pilot"])

    def click_return_home(self):
        self._input_handler.click(COORDINATES["return_home"])
    
    def click_rerun_dungeon(self):
        self._input_handler.click(COORDINATES["rerun_dungeon"])

    def click_decline_familiar(self):
        self._input_handler.click(COORDINATES["decline_familiar"])
    
    def click_accept_familiar(self):
        self._input_handler.click(COORDINATES["accept_familiar"])
        
    def click_confirm_familiar(self):
        self._input_handler.click(COORDINATES["confirm_familiar"])
    
    # Other
    def close_window(self):
        self._input_handler.escape()

    # ==========================================
    # COMBINED AND SPECIAL OPERATIONS
    # ==========================================
    
    def take_persuasion_screenshot(self) -> Image.Image:
        return self._screenshot_tool.screenshot(region=self._screenshot_tool.get_screenshot_region(COORDINATES["persuasion_top_left"], COORDINATES["persuasion_bottom_right"]))
    
    def get_available_worms(self) -> list[WormRarity]:
        available_worms = []
        screenshot = self._screenshot_tool.screenshot()
        for i in range(1, 5):
            worm_color = screenshot.getpixel(WindowHandler.get_absolute_coordinates(COORDINATES[f"worm_box_{i}"]))
            if worm_color == COMMON_WORM_COLOR:
                available_worms.append(WormRarity.COMMON)
            elif worm_color == RARE_WORM_COLOR:
                available_worms.append(WormRarity.RARE)
            elif worm_color == EPIC_WORM_COLOR:
                available_worms.append(WormRarity.EPIC)
            elif worm_color == LEGENDARY_WORM_COLOR:
                available_worms.append(WormRarity.LEGENDARY)
        return available_worms
    
    def current_worm(self) -> WormRarity:
        worm_color = self._screenshot_tool.screenshot().getpixel(WindowHandler.get_absolute_coordinates(COORDINATES["worm_bar_box"]))
        if worm_color == COMMON_WORM_COLOR:
             return WormRarity.COMMON
        elif worm_color == RARE_WORM_COLOR:
            return WormRarity.RARE
        elif worm_color == EPIC_WORM_COLOR:
            return WormRarity.EPIC
        elif worm_color == LEGENDARY_WORM_COLOR:
            return WormRarity.LEGENDARY
        elif worm_color == NO_WORM_COLOR:
            return WormRarity.NONE
        raise PixelColorMismatchError()

    def select_worm(self, rarity: WormRarity, available_worms: list[WormRarity]):
        rarity_weights = {
            WormRarity.LEGENDARY: 1,
            WormRarity.EPIC: 2,
            WormRarity.RARE: 3,
            WormRarity.COMMON: 4,
        }

        available_weights = {worm: rarity_weights[worm] for worm in available_worms}
        sorted_worms = sorted(available_weights, key=available_weights.get)

        box_index = sorted_worms.index(rarity) + 1
        self._input_handler.click(COORDINATES[f"worm_box_{box_index}"])
    
    def wait_till_ready(self, 
                        expected_state_callback: callable, 
                        timeout: int = 60, 
                        screenshot_cooldown: float = 0.5, 
                        raise_error: bool = True,
                        focus_once: bool = True) -> bool:
        if focus_once:
            self._window_handler.focus_window()
        start_time = time.time()
        while not expected_state_callback():
            if time.time() - start_time > timeout:
                if raise_error:
                    raise TimeoutStateError(expected_state_callback.__name__, timeout)
                return False
            time.sleep(screenshot_cooldown)
        return True

