from core.models.Coordinates import Coordinates
from core.models.ColorCoordinates import ColorCoordinates
from core.WindowHandler import WindowHandler
from core.constants.GuiData import APPLICATION_NAME, COORDINATES_ICON_PATH, COORDINATE_TOOL_FONT, COORDINATE_TOOL_SMALL_FONT, COORDINATE_TOOL_NAME, \
                                   COORDINATE_AUTOGENERATED_FILE
from core.constants.GeneratedCoordinates import COORDINATES_AUTO_GENERATED

from customtkinter import CTkSegmentedButton, CTk, CTkLabel, CTkEntry, CTkButton, set_appearance_mode
from enum import Enum
from CTkListbox import CTkListbox
from pygetwindow import getWindowsWithTitle
from pyperclip import copy
from mss import mss
from numpy import array
from pyautogui import position
from pynput import mouse

class CoordinateType(Enum):
    COORDINATES = "   Coordinates   "
    COLOR_COORDINATES = "ColorCoordinates"

class CoordinateManagerApp(CTk):
    def __init__(self):
        super().__init__()
        self.iconbitmap(COORDINATES_ICON_PATH)
        self.title(COORDINATE_TOOL_NAME)
        self.geometry("545x350")
        self.resizable(False, False)

        self.coordinates_dict = COORDINATES_AUTO_GENERATED
        self.selected_key = None
        self.selected_coordinate = None  
        self.current_coordinate = None   

        # UI
        values = [CoordinateType.COORDINATES.value,CoordinateType.COLOR_COORDINATES.value]
        button_width = 200

        self.switch = CTkSegmentedButton(self, values=values)
        self.switch.set(CoordinateType.COORDINATES.value)
        self.listbox = CTkListbox(self, width=250, height=300, font=COORDINATE_TOOL_FONT)
        self.current_label = CTkLabel(self, text="Current: None", font=COORDINATE_TOOL_SMALL_FONT)
        self.selected_label = CTkLabel(self, text="Selected: None", font=COORDINATE_TOOL_SMALL_FONT)
        self.entry_label = CTkLabel(self, text="New Key Name:", font=COORDINATE_TOOL_FONT)
        self.key_entry = CTkEntry(self, width=200, font=COORDINATE_TOOL_FONT, placeholder_text="Enter new key name")
        self.add_btn = CTkButton(self, text="Add as New Key", command=self.add_new_key, font=COORDINATE_TOOL_FONT, width=button_width)
        self.replace_btn = CTkButton(self, text="Replace Selected Key", command=self.replace_key, font=COORDINATE_TOOL_FONT, width=button_width)
        self.copy_btn = CTkButton(self, text="Copy Selected Coordinate", command=self.copy_coordinate, font=COORDINATE_TOOL_FONT, width=button_width)
        
        self.switch.grid(row=0, column=1, padx=8, pady=5, sticky="w")
        self.listbox.grid(row=0, column=0, rowspan=7, padx=10, pady=10, sticky="ns")
        self.current_label.grid(row=1, column=1, padx=10, pady=5, sticky="w")
        self.selected_label.grid(row=2, column=1, padx=10, pady=5, sticky="w")
        self.entry_label.grid(row=3, column=1, padx=10, pady=5, sticky="w")
        self.key_entry.grid(row=3, column=1, padx=10, pady=5, sticky="w")
        self.add_btn.grid(row=4, column=1, padx=10, pady=5, sticky="w")
        self.replace_btn.grid(row=5, column=1, padx=10, pady=5, sticky="w")
        self.copy_btn.grid(row=6, column=1, padx=10, pady=5, sticky="w")

        self.listbox.bind("<<ListboxSelect>>", self.on_select)

        self.populate_listbox()

        self.listener = mouse.Listener(on_click=self.on_click)
        self.listener.start()

        try:
            self.window = getWindowsWithTitle(APPLICATION_NAME)[0]
        except IndexError:
            self.window = None

        self.update_current_coordinate()  


    def flatten_dict(self, d, parent_key=''):
            items = []
            for k, v in d.items():
                new_key = f"{parent_key}.{k}" if parent_key else k
                if isinstance(v, dict):
                    items.extend(self.flatten_dict(v, new_key))
                else:
                    items.append(new_key)
            return items
            
    def populate_listbox(self):
        self.listbox.forget()
        self.listbox.delete(0, "end")
        keys = self.flatten_dict(self.coordinates_dict)
        for key in keys:
            self.listbox.insert("end", key)
        self.listbox.grid()

    def on_select(self, event):
        selection = self.listbox.curselection()
        self.selected_key = self.listbox.get(selection)

    def get_pixel_color(self, x, y):
        with mss() as sct:
            monitor = {"top": y, "left": x, "width": 1, "height": 1}
            screenshot = sct.grab(monitor)
            pixel = array(screenshot.pixel(0, 0))  # (R, G, B, A)
            return pixel[:3]  
    
    def update_current_coordinate(self):
        x, y = position()
        if self.window:
            left, top, right, bottom  = WindowHandler.get_game_dimension()

            if (x >= left and x <= right) and (y >= top and y <= bottom):
                rel_x = int(x - left)
                rel_y = int(y - top)

                if self.switch.get() == CoordinateType.COORDINATES.value:
                    self.current_coordinate = Coordinates(rel_x, rel_y)
                elif self.switch.get() == CoordinateType.COLOR_COORDINATES.value:
                    color = self.get_pixel_color(x, y)
                    self.current_coordinate = ColorCoordinates(rel_x, rel_y, *color)
                self.current_label.configure(text=f"Current: {self.current_coordinate}")
            else:
                self.current_coordinate = None
                self.current_label.configure(text="Current: Outside the window")
        else:
            self.current_coordinate = None
            self.current_label.configure(text="Current: Window not found")
        self.after(10, self.update_current_coordinate)

    def on_click(self, x, y, button, pressed):
        if button == mouse.Button.right and pressed:
            # Only save if inside the window
            if self.window:
                if self.current_coordinate:
                    self.selected_coordinate = self.current_coordinate
                    self.selected_label.configure(text=f"Selected: {self.selected_coordinate}")
                else:
                    self.selected_coordinate = None
                    self.selected_label.configure(text="Selected: No coordinate selected")
            else:
                self.selected_coordinate = None
                self.selected_label.configure(text="Selected: None")

    def add_new_key(self):
        key = self.key_entry.get().strip()
        if key and self.selected_coordinate:
            self.create_key(key)
            self.populate_listbox()
            self.write_coordinates_to_file()

    def replace_key(self):
        if self.selected_key and self.selected_coordinate:
            self.create_key(self.selected_key)
            self.listbox.selection_clear()
            self.write_coordinates_to_file()
    
    def create_key(self, key):
        keys = key.split('.')
        if len(keys) > 1:
            d = self.coordinates_dict
            for k in keys[:-1]:
                if k not in d or not isinstance(d[k], dict):
                    d[k] = {}
                d = d[k]
            d[keys[-1]] = self.selected_coordinate
        else:
            self.coordinates_dict[key] = self.selected_coordinate

    def write_coordinates_to_file(self):
        header = (
            f"# Auto-generated by {COORDINATE_TOOL_NAME}\n"
            "#\n"
            "# WARNING: Any changes to this file will be overwritten.\n"
        )
        modules = "from core.models.Coordinates import Coordinates\nfrom core.models.ColorCoordinates import ColorCoordinates"

        with open(COORDINATE_AUTOGENERATED_FILE, "w", encoding="utf-8") as writer:
            writer.write(header + "\n")
            writer.write(modules + "\n\n")
            writer.write("COORDINATES_AUTO_GENERATED = {\n")

            self.write_dict(self.coordinates_dict, writer)
            writer.write("}\n")

    def write_dict(self, d, writer, indent=1):
        for key, value in d.items():
            if isinstance(value, dict):
                writer.write("    " * indent + f'"{key}": {{\n')
                self.write_dict(value, writer, indent + 1)
                writer.write("    " * indent + "},\n")
            else:
                writer.write("    " * indent + f'"{key}": {value},\n')

    def copy_coordinate(self):
        if self.selected_coordinate:
            copy(self.selected_coordinate)

if __name__ == "__main__":
    set_appearance_mode("dark")
    app = CoordinateManagerApp()
    app.mainloop()


# Add Switch mode color or normal
# Add other column with value of coordinate